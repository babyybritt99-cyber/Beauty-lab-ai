<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Beauty Lab AI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body{font-family:Arial;background:#111;color:#fff;text-align:center;padding:20px}
    button{padding:12px 14px;font-size:16px;margin:10px;background:#2b5cff;color:#fff;border:none;border-radius:10px}
    button:disabled{opacity:.5}
    .card{max-width:720px;margin:0 auto 16px auto;padding:14px;border:1px solid #222;border-radius:14px;background:#151515;text-align:left}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    canvas{width:100%;max-width:520px;border-radius:12px;border:1px solid #222;margin-top:10px;background:#0d0d0d}
    pre{white-space:pre-wrap;background:#0d0d0d;border:1px solid #222;border-radius:12px;padding:12px;min-height:110px}
    small{color:#bdbdbd}
    .hTitle{margin:0 0 10px 0}
    .item{background:#0d0d0d;border:1px solid #222;border-radius:12px;padding:10px;margin-top:10px}
    a{color:#8fb1ff}
  </style>
</head>

<body>

  <h1>Beauty Lab AI</h1>
  <p><small>Private AI Beauty System • All analysis runs locally • No uploads</small></p>

  <div class="card">
    <h2 class="hTitle">1) Analyze Photo</h2>
    <div class="row">
      <input id="photo" type="file" accept="image/*" />
      <button id="analyze" disabled>Analyze Photo</button>
      <button id="export" title="Download your saved history as a file">Export History</button>
    </div>

    <canvas id="canvas"></canvas>

    <h3>Results</h3>
    <pre id="results">Upload a photo to begin.</pre>
  </div>

  <div class="card">
    <h2 class="hTitle">2) History (Saved on this device)</h2>
    <div class="row">
      <button id="refresh">Refresh History</button>
      <button id="clear">Clear History</button>
    </div>
    <div id="history"></div>
    <p><small>Tip: Use the same lighting and distance each time for accurate tracking.</small></p>
  </div>

<script type="module">
  // --- IndexedDB helpers (same as db.js but embedded to keep it simple) ---
  const DB_NAME="beautylab";
  const STORE="results";

  function openDB(){
    return new Promise((resolve,reject)=>{
      const req=indexedDB.open(DB_NAME,1);
      req.onupgradeneeded=()=>{ req.result.createObjectStore(STORE,{keyPath:"id"}); };
      req.onsuccess=()=>resolve(req.result);
      req.onerror=()=>reject(req.error);
    });
  }

  async function saveResult(payload){
    const db=await openDB();
    return new Promise((resolve,reject)=>{
      const tx=db.transaction(STORE,"readwrite");
      tx.objectStore(STORE).put(payload);
      tx.oncomplete=()=>resolve(true);
      tx.onerror=()=>reject(tx.error);
    });
  }

  async function getResults(){
    const db=await openDB();
    return new Promise((resolve,reject)=>{
      const tx=db.transaction(STORE,"readonly");
      const req=tx.objectStore(STORE).getAll();
      req.onsuccess=()=>resolve(req.result||[]);
      req.onerror=()=>reject(req.error);
    });
  }

  async function clearResults(){
    const db=await openDB();
    return new Promise((resolve,reject)=>{
      const tx=db.transaction(STORE,"readwrite");
      tx.objectStore(STORE).clear();
      tx.oncomplete=()=>resolve(true);
      tx.onerror=()=>reject(tx.error);
    });
  }

  // --- UI ---
  const photo=document.getElementById("photo");
  const analyze=document.getElementById("analyze");
  const canvas=document.getElementById("canvas");
  const results=document.getElementById("results");
  const historyEl=document.getElementById("history");
  const refreshBtn=document.getElementById("refresh");
  const clearBtn=document.getElementById("clear");
  const exportBtn=document.getElementById("export");

  let imageBitmap;

  function clamp(n,min,max){ return Math.max(min,Math.min(max,n)); }

  photo.onchange=async()=>{
    const file=photo.files?.[0];
    if(!file) return;
    imageBitmap=await createImageBitmap(file);
    const ctx=canvas.getContext("2d",{willReadFrequently:true});

    // resize for speed + consistency
    const maxW=720;
    const scale=Math.min(1, maxW/imageBitmap.width);
    canvas.width=Math.round(imageBitmap.width*scale);
    canvas.height=Math.round(imageBitmap.height*scale);

    ctx.drawImage(imageBitmap,0,0,canvas.width,canvas.height);
    analyze.disabled=false;
    results.textContent="Ready. Tap Analyze Photo.";
  };

  analyze.onclick=async()=>{
    const ctx=canvas.getContext("2d",{willReadFrequently:true});
    const img=ctx.getImageData(0,0,canvas.width,canvas.height);

    let brightness=0;
    let redness=0;
    let shine=0;

    // quick metrics (proxies, not diagnosis)
    for(let i=0;i<img.data.length;i+=4){
      const r=img.data[i], g=img.data[i+1], b=img.data[i+2];
      const lum=(r+g+b)/3;
      brightness+=lum;
      redness+=r-(g+b)/2;
      if(lum>235) shine++;
    }

    const px=img.data.length/4;
    brightness/=px;
    redness/=px;
    const shineRatio=shine/px;

    // simple scores (transparent, adjustable later)
    const rednessN=clamp((redness+30)/120,0,1);   // normalize
    const dullnessN=clamp((180-brightness)/120,0,1);
    const oilinessN=clamp(shineRatio*6,0,1);

    const skinScore=Math.round(100*(1-(0.55*rednessN+0.30*dullnessN+0.15*oilinessN)));
    const glowScore=Math.round((skinScore+80)/2);

    const summary =
`Skin Score: ${skinScore}
Glow Score: ${glowScore}

Brightness(avg): ${Math.round(brightness)}
Redness index: ${Math.round(redness)}
Shine ratio: ${shineRatio.toFixed(4)}

Honest interpretation (photo-based, not medical):
- Redness proxy: ${rednessN>0.66?"High":rednessN>0.33?"Moderate":"Low"}
- Dullness proxy: ${dullnessN>0.66?"High":dullnessN>0.33?"Moderate":"Low"}
- Oiliness proxy: ${oilinessN>0.66?"High":oilinessN>0.33?"Moderate":"Low"}

Notes:
- Lighting/filters can change results a lot.
- Use the same lighting + distance for tracking.`;

    results.textContent=summary;

    const entry={
      id: Date.now(),
      createdAt: new Date().toISOString(),
      scores: { skinScore, glowScore },
      metrics: {
        brightness: Number(brightness.toFixed(2)),
        redness: Number(redness.toFixed(2)),
        shineRatio: Number(shineRatio.toFixed(6))
      }
    };

    await saveResult(entry);
    await renderHistory();
  };

  async function renderHistory(){
    const logs=(await getResults()).sort((a,b)=>b.id-a.id);
    if(!logs.length){
      historyEl.innerHTML="<p><small>No saved entries yet.</small></p>";
      return;
    }
    historyEl.innerHTML="";
    for(const l of logs){
      const div=document.createElement("div");
      div.className="item";
      div.innerHTML=
        `<div><b>${new Date(l.createdAt).toLocaleString()}</b></div>
         <div><small>Skin: ${l.scores.skinScore} • Glow: ${l.scores.glowScore}</small></div>
         <details>
           <summary><small>Details</small></summary>
           <pre>${escapeHtml(JSON.stringify(l,null,2))}</pre>
         </details>`;
      historyEl.appendChild(div);
    }
  }

  function escapeHtml(s){
    return s.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  refreshBtn.onclick=renderHistory;

  clearBtn.onclick=async()=>{
    await clearResults();
    await renderHistory();
    results.textContent="History cleared.";
  };

  exportBtn.onclick=async()=>{
    const logs=await getResults();
    const blob=new Blob([JSON.stringify(logs,null,2)],{type:"application/json"});
    const url=URL.createObjectURL(blob);
    const a=document.createElement("a");
    a.href=url;
    a.download="beauty-lab-ai-history.json";
    a.click();
    URL.revokeObjectURL(url);
  };

  renderHistory();
</script>

</body>
</html>
